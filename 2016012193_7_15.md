# 第一天学习日志

​	第一天算是做准备，下了一些软件，讲了一下sort和树相关的基础。

----

* 下载的小东西们

  1.文档编辑器 ：notepad+

  2.用来git代码的： git

  3.排版软件： markdown

  4.python+jupyter notebook

* 乘法中的算法

  ###### 1.普通的算法：

  ​	和位数n的平方相关；

  ###### 2.分而治之算法a：

  ​	我们可以把数分解x=100a+b，y=100c+d，xy=1000aa+100(ad+bc)+bd，把一个n位数的乘法转化成4个n/2位数的乘法，计算量并没有发生变化；

  ###### 3.分而治之算法b：

  ​	我们在上述基础上ad+bc=(a+b)(c+d)-ac-bd，从而把一个n位数的乘法转化成3个n/2位数的乘法，复杂度为O(N^1.6)（其实是log2(3)）；

* sort相关

  ###### 1.插入排序

  ​	从第一个开始和之前的有序排列排，由于之前的排列有序，所以单个值只要比一趟即可，总的复杂度为O(n^2)；

  ###### 2.合并排序

  ​	把一个序列分成两个部分，两部分可以递归进行排序，再对两个有序列进行排列，只需要O(n)复杂度即可，因此最后总的复杂度为O(nlogn)；

  ###### 3.Bogo排序

  ​	随机排序，只需要检验它是不是有序列即可，随机性较强；

  ###### 4.Quick Sort（快速排序）

  ​	随机选一个，把比它小的排在左边，比它大的排在右边，然后在左右两边进行递归排序即可，总的复杂度为O(nlogn)，同样具有一定的随机性。

* 树相关

  ###### 1.BST（二叉搜索树）

  ​	二叉树，其中左子叶的所有值比父节点小，右子叶的所有值比父节点大；它的查找/插入/删除的复杂度均为O(logn)；

  ###### 2.红黑树

  ​	二叉搜索树的运算复杂度一般为O(logn)，但是某些情况下（比如说所有的子叶都是左子叶），平衡性会很差，最后的结果会近似于链表，查找的复杂度会很高；因此将结点染色得到的二叉搜索树，它具有相对平衡的特点（最高深度不会大于平均深度的两倍），C标准库当中的很多函数都是用红黑树编程的。

* 又出现的小问题

  1.print在python不同版本里不一样，在2版本可以直接print x，但是在3版本中就要加括号了，嗯，再下一个吧；

  2.与红黑树相似的还有平衡二叉树（AVL），其实复杂度也没有什么差别，以后再好好复习一下。

  